# This workflow validates our Terraform modules, selects our deployment's environment, and then deploys our Terraform code.
name: deploy
run-name: ${{ github.workflow }}
on:
  push:
    branches:
      - main
    paths:
      - terraform/environments/**
  pull_request:
    branches:
      - main
    paths:
      - terraform/environments/**
  workflow_dispatch:
    inputs:
      environment:
        type: environment
        required: true
        description: "Specify the deployment's environment"
      tf_apply:
        type: boolean
        default: true
        required: true
        description: "Run `terraform apply`"

# Cancel in progress workflows based on the following:
# - if the trigger was push/pull_request
# - if the trigger was workflow_dispatch and the environment is the same
#
# Simultaneous deployment is only allowed when its manually triggered and
# targets different environments, otherwise the most recently trigger workflow
# gets executed.
concurrency:
  group: ${{ github.workflow }}-${{ github.event.inputs.environment }}
  cancel-in-progress: true

permissions:
  actions: read
  contents: read
  id-token: write
  pull-requests: write

env:
  TERRAFORM_REL_ENV_DIR: terraform/environments
  TERRAFORM_ABS_ENV_DIR: ${{ github.workspace }}/terraform/environments

jobs:
  validate-modules:
    name: validate-modules-workflow-status
    runs-on: ubuntu-latest
    steps:
      - name: Validate workflow status
        uses: LASER-Yi/workflow-status@v0.1.0
        id: validate-modules-workflow-status
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          workflow: validate_modules.yaml
          branch: main
          wait: true

      - name: Check workflow status
        if: steps.validate-modules-workflow-status.conclusion == 'failure'
        run: |
          echo "Latest run of validate-modules was a failure"
          exit 1

  select-environments:
    name: select-environments
    needs: validate-modules
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.select-environments.outputs.environments || steps.provided-environment.outputs.environment }}
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        if: github.event_name == 'push' || github.event_name == 'pull_request'
        uses: actions/checkout@v3

      - name: Find which environment/s changed
        if: github.event_name == 'push' || github.event_name == 'pull_request'
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            development:
              - '**/development/**'
            staging:
              - '**/staging/**'
            production:
              - '**/production/**'

      - name: Select environments
        if: github.event_name == 'push' || github.event_name == 'pull_request'
        id: select-environments
        run: |
          environments=()
          if [ "${{ steps.filter.outputs.development }}" == "true" ]; then
            environments+=("development")
          fi
          if [ "${{ steps.filter.outputs.staging }}" == "true" ]; then
            environments+=("staging")
          fi
          if [ "${{ steps.filter.outputs.production }}" == "true" ]; then
            environments+=("production")
          fi
          environments_json=$(jq -c -n '$ARGS.positional' --args "${environments[@]}")
          echo "Selected environments: $environments_json"
          echo "environments=$environments_json" >> $GITHUB_OUTPUT

      - name: Provided environment
        if: github.event_name == 'workflow_dispatch'
        id: provided-environment
        run: |
          environment_json=$(jq -c -n '$ARGS.positional' --args "${{ inputs.environment }}")
          echo "Selected environment: $environment_json"
          echo "environment=$environment_json" >> $GITHUB_OUTPUT

  deploy:
    name: deploy-to-${{ matrix.environment }}
    needs: select-environments
    runs-on: ubuntu-latest
    environment: ${{ matrix.environment }}

    # The flow of execution is the following:
    # 1. Deploy to the development environment (if changes were made to terraform/environments/development)
    # 2. Deploy to the staging     environment (if changes were made to terraform/environments/staging    and the development deployment completed successfully)
    # 3. Deploy to the production  environment (if changes were made to terraform/environments/production and the staging     deployment completed successfully)
    strategy:
      max-parallel: 1
      fail-fast: true
      matrix:
        environment: ${{ fromJson(needs.select-environments.outputs.environments) }}
    defaults:
      run:
        shell: bash
        working-directory: ${{ env.TERRAFORM_ABS_ENV_DIR }}/${{ matrix.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        id: tfsec
        with:
          working_directory: ${{ env.TERRAFORM_ABS_ENV_DIR }}/${{ matrix.environment }}
          soft_fail: false
          additional_args: "--tfvars-file ${{ env.TERRAFORM_REL_ENV_DIR }}/${{ matrix.environment }}/${{ matrix.environment }}.auto.tfvars --concise-output"
          github_token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Terraform fmt
        id: fmt
        run: terraform fmt -check
        continue-on-error: true

      - name: Terraform init
        id: init
        run: terraform init
        continue-on-error: true

      - name: Terraform validate
        id: validate
        run: terraform validate -no-color
        continue-on-error: true

      - name: Terraform plan
        id: plan
        run: |
          terraform plan \
            -no-color -input=false \
            -out=${{ matrix.environment }}.tfplan \
            -var="client_id=${{ secrets.CLIENT_ID }}" \
            -var="tenant_id=${{ secrets.TENANT_ID }}" \
            -var="subscription_id=${{ secrets.SUBSCRIPTION_ID }}"
        continue-on-error: true

      - name: Update pull request
        uses: actions/github-script@v6
        if: github.event_name == 'pull_request'
        id: update-pr
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            // 1. Retrieve existing bot comments for the PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            })
            const botComment = comments.find(comment => {
              return comment.user.type === 'Bot' && comment.body.includes('${{ matrix.environment }}')
            })

            // 2. Prepare format of the comment
            var character_limit_reached = "false"
            var output = `#### Tfsec Scan Result ㊙️\`${{ steps.tfsec.outcome }}\`
            #### Terraform Format and Style 🖌\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization ⚙️\`${{ steps.init.outcome }}\`
            #### Terraform Validation 🤖\`${{ steps.validate.outcome }}\`
            <details><summary>Validation Output</summary>

            \`\`\`hcl
            ${{ steps.validate.outputs.stdout }}
            \`\`\`

            </details>

            #### Terraform Plan 📖\`${{ steps.plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`hcl
            ${{ steps.plan.outputs.stdout }}
            \`\`\`

            </details>

            *Actor: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`${{ env.TERRAFORM_REL_ENV_DIR }}/${{ matrix.environment }}\`, Workflow: \`${{ github.workflow }}\`*`;

            // 3. Check if character limit was reached and update accordingly
            if (output.length > 65536) {
              character_limit_reached = "true"
              output = `#### Tfsec Scan Result ㊙️\`${{ steps.tfsec.outcome }}\`
              #### Terraform Format and Style 🖌\`${{ steps.fmt.outcome }}\`
              #### Terraform Initialization ⚙️\`${{ steps.init.outcome }}\`
              #### Terraform Validation 🤖\`${{ steps.validate.outcome }}\`
              <details><summary>Validation Output</summary>
              
              \`\`\`hcl
              ${{ steps.validate.outputs.stdout }}
              \`\`\`
              
              </details>
              
              #### Terraform Plan 📖\`${{ steps.plan.outcome }}\`
              
              <details><summary>Show Plan</summary>
              \`\`\`hcl
              Terraform's plan was too big to fit in a PR comment. Check the following step's summary to see the plan.
              \`\`\`
              
              </details>
              
              *Actor: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`${{ env.TERRAFORM_REL_ENV_DIR }}/${{ matrix.environment }}\`, Workflow: \`${{ github.workflow }}\`*`;
            }

            // 4. If we have a comment, update it, otherwise create a new one
            if (botComment) {
              github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: output
              })
            } else {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: output
              })
            }

            return character_limit_reached

      - name: Terraform plan summary
        if: steps.update-pr.outputs.result == 'true'
        run: echo "#### Terraform Plan 📖\n\`\`\`hcl{{ steps.plan.outputs.stdout }}\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Check tfsec status
        if: steps.tfsec.outcome == 'failure'
        run: exit 1

      - name: Check terraform status
        if: steps.fmt.outcome == 'failure' || steps.init.outcome == 'failure' || steps.validate.outcome == 'failure'
        run: exit 1

      - name: Terraform apply
        if: inputs.tf_apply || (github.ref == 'refs/heads/main' && github.event_name == 'push')
        id: apply
        run: |
          terraform apply \
            ${{ matrix.environment }}.tfplan \
            -no-color -auto-approve \
            -var="client_id=${{ secrets.CLIENT_ID }}" \
            -var="tenant_id=${{ secrets.TENANT_ID }}" \
            -var="subscription_id=${{ secrets.SUBSCRIPTION_ID }}"
